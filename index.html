<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>P01 – T03: Análisis Crítico de un Patrón de Diseño Utilizado en el Proyecto</title>
  <style>
    body{
      font-family: Arial, Helvetica, sans-serif;
      line-height: 1.6;
      margin: 24px;
      color: #111;
    }
    header{
      margin-bottom: 18px;
      padding-bottom: 12px;
      border-bottom: 1px solid #ccc;
    }
    h1{ font-size: 1.6rem; margin: 0 0 8px 0; }
    .meta{ margin: 0; }
    h2{ margin-top: 22px; font-size: 1.25rem; }
    h3{ margin-top: 16px; font-size: 1.1rem; }
    ul{ margin-top: 6px; }
    pre{
      background: #f6f6f6;
      border: 1px solid #ccc;
      padding: 12px;
      overflow-x: auto;
      white-space: pre;
      border-radius: 6px;
    }
    code{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.95em;
    }
    .boldline{
      font-weight: 700;
      margin-top: 12px;
      margin-bottom: 6px;
    }
  </style>
</head>
<body>

  <header>
    <h1>P01 – T03: Análisis Crítico de un Patrón de Diseño Utilizado en el Proyecto</h1>
    <p class="meta"><strong>Magdiel Garcia</strong></p>
    <p class="meta">Universidad Linda Vista</p>
  </header>

  <h2>Introducción</h2>
  <p>
    El proyecto desarrollado consiste en una API para la gestión del Hogar de Varones Universitarios (HVU),
    cuyo propósito es administrar usuarios, asistencia, reportes y sanciones. El sistema fue implementado
    utilizando Node.js con Express como framework principal.
  </p>
  <p>
    Debido a que el proyecto maneja múltiples módulos, reglas de negocio y posibles ampliaciones futuras,
    se decidió implementar el patrón Clean Architecture. Este patrón fue seleccionado porque permite separar
    claramente la lógica del negocio de la infraestructura (base de datos, framework, rutas HTTP), favoreciendo
    la mantenibilidad y escalabilidad del sistema.
  </p>
  <p>
    El objetivo de este análisis es evaluar críticamente la efectividad de Clean Architecture dentro del
    contexto real del proyecto HVU.
  </p>

  <h2>Descripción del Patrón y su Implementación</h2>

  <h3>¿Qué es Clean Architecture?</h3>
  <p>Clean Architecture es un patrón arquitectónico que organiza el sistema en capas independientes donde:</p>
  <ul>
    <li>El dominio contiene las reglas del negocio.</li>
    <li>La aplicación orquesta los casos de uso.</li>
    <li>La infraestructura maneja detalles técnicos.</li>
    <li>La capa de presentación gestiona la interacción externa (HTTP).</li>
  </ul>
  <p>La regla principal es que las dependencias siempre apuntan hacia el núcleo del sistema (el dominio).</p>

  <h3>Implementación en el Proyecto</h3>
  <p>El proyecto fue organizado en las siguientes capas:</p>

  <p class="boldline">1. Presentation (Controllers y Routes):</p>
  <ul>
    <li>Manejan las peticiones HTTP.</li>
    <li>No contienen lógica compleja.</li>
    <li>Ejemplo: user.controller.js</li>
  </ul>

  <p class="boldline">2. Application (Use Cases):</p>
  <ul>
    <li>Contienen la lógica del negocio.</li>
    <li>Ejemplo: CreateUserUseCase, RegisterAttendanceUseCase.</li>
  </ul>

  <p class="boldline">3. Domain (Entidades):</p>
  <ul>
    <li>Define modelos como User, Attendance, Report.</li>
    <li>Contiene validaciones esenciales.</li>
  </ul>

  <p class="boldline">4. Infrastructure (Repositorios y Base de Datos):</p>
  <ul>
    <li>Implementa acceso a SQL.</li>
    <li>Contiene clases como SqlUserRepository.</li>
  </ul>

  <p>Ejemplo real de separación:</p>

  <pre><code>// Controlador (solo recibe y responde)
export const createUserController = (useCase) =&gt; async (req, res) =&gt; {
  const result = await useCase.execute(req.body);
  res.json(result);
};
</code></pre>

  <pre><code>// Caso de uso (logica del negocio)
async execute(data) {
  if (!data.email) {
    throw new Error("Email obligatorio");
  }
  return await this.userRepository.create(data);
}
</code></pre>

  <p>
    Aquí se observa que el controlador no conoce cómo se guarda el usuario; solo ejecuta el caso de uso.
  </p>

  <h2>Análisis Crítico del Patrón</h2>

  <h3>Efectividad</h3>
  <p>
    Clean Architecture fue efectiva porque permitió organizar el sistema desde el inicio evitando que la lógica
    del negocio se mezclara con Express o con la base de datos. Esto redujo errores estructurales y mejoró la
    claridad del código.
  </p>

  <h3>Mantenibilidad</h3>
  <p>
    La mantenibilidad fue uno de los principales beneficios. Si se requiere modificar la base de datos o cambiar
    la estructura de persistencia, los cambios se limitan a la capa de infraestructura. La lógica del negocio
    permanece intacta.
  </p>
  <p>
    Por ejemplo, si en el futuro se cambia de SQL a MongoDB, solo se modifica el repositorio concreto.
  </p>

  <h3>Escalabilidad</h3>
  <p>
    El patrón permitió agregar nuevos módulos (como reportes o sanciones) siguiendo la misma estructura sin
    afectar módulos existentes. Esto demuestra que el sistema puede crecer de forma ordenada.
  </p>

  <h3>Complejidad</h3>
  <p>
    Una desventaja observada es que aumenta la cantidad de archivos y requiere mayor disciplina. Para
    desarrolladores sin experiencia, puede resultar complejo comprender todas las capas al inicio.
  </p>

  <h3>Desempeño</h3>
  <p>
    El impacto en el rendimiento fue mínimo. Aunque existen más niveles de abstracción, el tiempo de ejecución
    no se vio afectado de manera significativa. El beneficio estructural compensa ampliamente este pequeño costo
    adicional.
  </p>

  <h2>Comparación con Alternativas</h2>

  <h3>Alternativa 1: MVC</h3>
  <p>
    MVC separa Modelo, Vista y Controlador. Es más sencillo de implementar inicialmente, pero en proyectos
    grandes los controladores tienden a acumular lógica de negocio, lo que dificulta el mantenimiento.
  </p>

  <p>Comparado con MVC:</p>
  <ul>
    <li>Clean Architecture ofrece mejor separación de responsabilidades.</li>
    <li>MVC es más simple pero menos escalable en proyectos medianos/grandes.</li>
  </ul>

  <h3>Alternativa 2: Arquitectura Monolítica Simple</h3>
  <p>Otra opción habría sido una estructura básica sin separación estricta por capas.</p>

  <p>Ventajas:</p>
  <ul>
    <li>Menor complejidad inicial.</li>
    <li>Desarrollo más rápido.</li>
  </ul>

  <p>Desventajas:</p>
  <ul>
    <li>Alto acoplamiento.</li>
    <li>Difícil mantenimiento.</li>
    <li>Escalabilidad limitada.</li>
  </ul>

  <p>
    En comparación, Clean Architecture ofrece una estructura más robusta y preparada para el crecimiento del
    sistema HVU.
  </p>

  <h2>Conclusiones y Recomendaciones</h2>
  <p>
    El análisis demuestra que Clean Architecture fue una decisión adecuada para el proyecto HVU. Permitió
    mantener una estructura organizada, facilitar el mantenimiento y preparar el sistema para futuras
    ampliaciones.
  </p>
  <p>
    Aunque introduce mayor complejidad inicial, los beneficios en escalabilidad y claridad estructural superan
    esta desventaja. Para proyectos académicos pequeños podría parecer excesivo, pero para sistemas reales con
    múltiples módulos resulta altamente recomendable.
  </p>
  <p>
    Como aprendizaje clave, se concluye que la selección de un patrón debe basarse en la proyección de
    crecimiento del sistema y no únicamente en la facilidad de implementación inicial. Una arquitectura bien
    definida desde el principio reduce problemas técnicos a largo plazo y mejora la calidad del software.
  </p>

</body>
</html>
